\documentclass[11pt]{article}
\usepackage{pythontex,listings}
\usepackage{amssymb}
\usepackage{graphicx , caption , amsmath ,float, pgfplots , wrapfig , xepersian ,bbm}
\settextfont{Persian Modern}
\setdigitfont{Persian Modern}
\captionsetup{labelsep=none}
\begin{document}

\setlength{\textwidth}{180mm}
\setlength{\textheight}{235mm }
\setlength{\textwidth}{12cm}
\setlength{\textheight}{19.5cm}

\begin{persian}
\title{
\centerline{\includegraphics[scale=0.4]{project_pictures/title.jpg}}
پروژه سیگنال و سیستم

مخابرات طیف گسترده باینری
}
\author{
نام و نام خانوادگی:  آرش دهقانی99109133 
آرمان لطفعلی خانی 99109166
}
\date{}
\maketitle
\newpage


\textbf{در تمام کد پروژه اندیس 1 در نام سیگنال ها مربوط به مخابرات عادی و اندیس 2 در نام سیگنال ها مربوط به مخابرات طیف گسترده است.} 

تفاوت مخابرات طیف گسترده با مخابرات عادی در این است که در مخابرات طیف گسترده ما داده ها را گسترش میدهیم و بعد از مدولاتور در یک دنباله $PN$ رندوم ضرب میکنیم.

ابتدا داده ها را با دستور $randi$ تولید میکنیم. 
دنباله رندوم را هم با همین دستور ایجاد میکنیم تا دنباله های $-1$ و $1$ ایجاد شوند. 
با توجه به اینکه تفاوت مدولاسیون عادی با مدولاسیون \lr{bpsk} تنها تغییر فاز کسینوس ضرب شده در بیت‌های صفر به مقدار $\pi$ است، کافیست بیت‌ها را به 1و -1 تبدیل کرده سپس مدولاسیون عادی را روی آنها انجام دهیم.
\\ 
قبل از رسیدن به بلوک $modulator$ ما داده ها را برای طیف گسترش میدهیم. یعنی در بردار داده ها از هر داده، $M$ نمونه متوالی وجود دارد.(در مخابرات عادی در بردار داده ها، هر خانه مربوط به یک داده جدید است.) گسترش را به کمک ضرب $out product$ در متلب انجام میدهیم. 

از این به بعد بردار دامنه توابع مربوط به دو روش دارای بازه ی متفاوتی هستند. $n_1$(مخابرات عادی) از $0$ تا $N$(تعداد داده ها) و 
(مخابرات طیف گسترده)$n_2$ 
از 
$0$ تا $NM$ است.
\section{مدولاتور}
در این بخش داده های هر دو بخش را در 
$cos(2\pi f_m n)$ ضرب میکنیم.
که $f_m$ فرکانس مدولاتور و $n$ دامنه مربوطه است. این کار باعث شیقت در حوزه فرکانس به اندازه $fm$ و $-fm$ میشود. اگر $b[n]$ را بیت های داده بنامیم، تعریف میکنیم:
$$
x_2[n] = b_2[n] cos(2\pi f_m n)
$$
خروجی این بلوک در کد modulated نام دارد.


\begin{figure}[H]
\centerline{\includegraphics[scale=0.6]{project_imgs/descrete_modulation.png}}
\caption{تغییرات نمودار تبدیل فوریه سیگنال بعد از مدولاسیون و دمدولاسیون}
\end{figure}


\begin{figure}[H]
\centerline{\includegraphics[scale=0.3]{project_imgs/BPSK.jpg}}
\caption{مدولاسیون BPSK در حوزه زمان}
\end{figure}


با توجه به نمودار، برای همپوشانی نداشتن بخش‌های مختلف تبدیل فوریه سیگنال بعد از دمدولاسیون، دو شرط زیر باید برقرار باشند (پهنای باند سیگنال اصلی برابر $\omega_b$ فرض شده است):
\begin{equation}
\begin{split}
&2\Omega_c-\omega_b\geq \omega_b\Rightarrow \Omega_c\geq \omega_b \Rightarrow f_c\geq f_b\\
&2\Omega_c+\omega_b\leq 2\pi-\omega_b\Rightarrow f_c+f_b\leq \frac{1}{2}
\end{split}
\end{equation}
هر دو شرط نیز در طراحی فیلتر پایین گذر و تعیین فرکانس مدولاسیون در کد لحاظ شده‌اند.
\section{ضرب $PN$}
این بخش فقط برای طیف گسترده است و دنباله $PN$ که در اینجا $p[n]$ مینامیم در خروجی مدولاتور ضرب میشود. در واقعیت این رشته اعداد توسط تعدادی شیفت رجیستر با مشخصات خاص ساخته می‌شوند تا به تقریب اعداد تولید شده، رندوم باشند ولی ما اینجا مستقیما از دستورات تولید عدد رندوم استفاده کردیم تا نیازی به این تقریب نباشد.


خروجی این بلوک در کد $modulatedp2$ نام دارد.
\section{کانال}
حال سیگنال سینوسی($i[n]$) و نویز گاوسی ($g[n]$) به سیگنال عادی و طیف گسترده اضافه میشود. برای نویز گاوسی از تابع $wgn$ استفاده میکنیم. برای نویز سینوسی تابع نوشتیم و در یک $M file$ کنار فایل های اصلی قرار دادیم. دامنه‌ی سیگنال سینوسی تداخلی بزرگ است. ($َA>M$) در فایل تابع میتوان ضریب $\frac{A}{m}$  زا تغییر داد. حالت ایده آل برای jammer  این است که فرکانس بیت تداخلی برابر فرکانس مدولاتور باشد تا بیشینه تداخل را داشته باشد. در کد به طور پیش فرض این دو فرکانس مساوی اند.

خروجی این بلوک در کد noisedsignal نام دارد.
\section{ضرب دوباره $PN$}
در این قسمت دوباره همان دنباله ای را که در بخش 2 ضرب کردیم، ضرب میکنیم. اگر خروجی این بخش را $y[n]$ بنامیم، داریم:
$$
y[n] = p[n]^2x[n] + p[n] i[n] + p[n] g[n]
$$
که چون $p[n]$ 
$1$ یا $-1$ است، 
$p[n] ^2 = 1$

$$
y[n] = x[n] + p[n] i[n] + p[n]  g[n] 
$$
اثر $pn$ روی داده ها از بین میرود اما ضرب $pn$ روی نویز و بیت تداخلی باعث گسترش طیف آن میشود. در شکل زیر میبینیم که بیت تداخلی سینوسی( که $\delta$ در حوزه فوریه است) به واسطه ضرب $pn$ در حوزه فوریه پخش شده است. که بعدا با گذاشتن فیتر مناسب بخش کمتری از طیف آن عبور میکند. 
همجنین توجه داریم که ضرب $p[n]$ بر نویز گاوسی اثری ندارد. با توجه به اینکه نویز $g[n]$ توسط یک فرایند تصادفی تولید شده است و با فرض تصادفی بودن و همچنین \lr{iid} بودن مقادیر $p[n]$ در یک دوره داریم:
\begin{equation}
f_G(g)=f_{G|p=1}(g)\mathbb{P}(p=1)+f_{G|p=-1}(-g)\mathbb{P}(p=1)=\frac{1}{2}(f_G(g)+f_G(-g))=f_G(g)
\end{equation}
توجه داریم که در رابطه بالا فقط از فرض زوج بودن توزیع $f_G(g)$ استفاده دش بنابراین رابطه برای توزیع‌های دیگری بجز توزیع گاوسی نیز می‌تواند صادق باشد.
از این رابطه نتیجه می‌شود که خواص فرکانسی $p[n]g[n]$ با $g[n]$ یکسان است و فرقی بین مخابرات طیف گسترده و عادی از این نظر وجود ندارد.
\begin{figure}[H]
\centerline{\includegraphics[scale=0.3]{project_imgs/before&after.jpg}}
\caption{سیگنال اصلی و تداخلی : بالایی قبل ضرب دوباره و پایینی بعد ضرب دوباره}
\end{figure}

البته شکل بالا در تحلیل پیوسته زمان است ولی در گسسته زمان نیز همین گسترده شدن وجود دارد. اما یک فرق بین تحلیل پیوسته زمان و گسسته زمان وجود دارد و آن این است که $PN$ در تحلیل پیوسته زمان محدود باند است و در تحلیل گسسته زمان پهن باند. 

\begin{figure}[H]
\centerline{\includegraphics[scale=0.6]{project_imgs/pn.png}}
\caption{PN در حوزه فرکانس}
\end{figure}

خروجی این بلوک در کد pnremoved2 نام دارد.
\section{دمودولاسیون}
در این مرحله دوباره سیگتال را در $cos(2\pi f_m n)$ ضرب میکنیم یعنی در کسینوس با همان فرکانس مدولاتور. با این کار برعکس شیفت مدولاسیون را اعمال مبکنیم و بعد آن با یک فیلتر پایین گذر تنها طیف های مورد نظر را عبور میدهیم. برای فیلتر پایین گذر از کانولوشن با تابع $sinc(2\pi f_{sinc}n)$ بهره میبریم. کار دیگری که میتوان کرد. با توجه به اینکه فرکانس بیت تداخلی هم نزدیک فرکانس مدولاتور است، طیف هایی از بیت تداخلی از فیلتر عبور میکند.

خروجی دمودولاسیون در کد demodulated نام دارد. خروجی پایین گدر filtered  نام دارد.
\section{detector}
در این بخش $M$ نمونه را جمع میکنیم. بعد از دمدولاتور و فیلتر ما حاصل ضرب بیت تداخلی سینوسی در کسینوس دمودولاتور را داریم. با استفاده از اتحاد مثلثاتی، این حاصل ضرب در واقع دو تا سینوس با فرکانس های متفاوت ایجاد میکند. با جمع کردن $M$ نمونه، در واقع حاصل جمع نمونه های بیت های داده اصلی و چند شکل سینوسی را حساب میکنیم. ابن جمع در بدترین حالت، روی چند دوره تناوب تابع سینوسی و بخشی از دوره‌ی آن است. پس در حالی که حاصل جمع نمونه ها در حال افزایش است، حاصل جمع بیت سینوسی تداخلی تغییر چندانی نمیکند. اگر $s_k$ را جمع متناظر با بیت $k$ ام بدانیم، داریم:(بخش زیادی از نویز گوسی در فیلتر پایین گدر ار بین میرود و با توجه به کوچکی اثرش نسبت به بیت تداخلی، نگرانی ما در این بخش نیست)

$$
s_k = \sum_{(k-1)M}^{kM} (b_2[n] + A sin(\Omega n) p[n] )
$$
$$
s_k = \pm   M + \alpha A
$$
که $\alpha$ ضریبی کوپک تر از 1 است. 

هنوز اثر بیت تداخلی تا حدی وجود دارد.(با توجه به $A>M$) هر چند در طیف گسترده، بخشی از طیف های آن گسترده و حذف شده است. ما سه راه برای شناسایی بیت های خروجی داریم:


یکی اینکه اگر $s_k$ مثبت شد، بیت را $1$ و اگر منفی شد $-1$ اعلام کنیم. اما با توجه به روابط بالا روش بهتری نیز وجود دارد. فرض کنید بیت اطلاعاتی مثبت $1$  باشد: شاید اثر بیت تداخلی باعث منفی شدن بیت مثبت شود اما یک عدد منفی با اندازه نسبتا کوچک ایجاد کند. یا برای بیت اطلاعاتی $-1$ اتفاقی مشابه رخ دهد. به عبارت دیگر، ممکناست نویز خارجی یک عدد ثابت منفی بزرگی ایجاد کند که سیگنال ورودی \lr{detector} را به مقدار زیادی به بالا یا پایین شیفت دهد. برای رفع این مشکل نیز دو راه داریم: یکی اینکه میانگین همه داده‌ها را از آن کم کنیم، که موجب از دست رفتن مولفه \lr{dc} سیگنال اولیه می‌شود و می‌تواند خطا ایجاد کند. راه دوم این است که $thereshold$ را میانگین ماکزیمم و مینیموم $s_K$ ها بگذاریم تا از خطای گفته شده تا حد امکان جلوگیری کنیم. در این حالت، مولفه $f=0$ سیگنال اولیه نیز دچار تغییر نشده تمام اثرات نامطلوب حداکثر به فرم ضرب عدد ثابت در تبدیل فوریه سیگنال اولیه ظاهر می‌شوند. روش اول نیز در ابتدا آزمایش شده و از لحاظ عملی نیز خطای بسیار بالای آن (بین 40 تا 50 درصد) مشاهده شده است، بنابراین استفاده از روش سوم تنها راه قابل قبول است.
$$
thereshold = \frac{\min(s_k) + max(s_k)}{2}
$$ 
به عنوان مثال اگر بردار داده ها 
$-130$،$-120$،$-5$ و $20$ بود، منطقی تر آن است که $-5$ را 1 بگیریم. در حالی که در روش اول(با $thereshold$ صفر) آن را $-1$ تشخیص خواهیم داد.

خروجی در بردار data موجود است.
\section{نتایج}
4 فایل وجود دارد که خطای مخابرات عادی و طیف گسترده را به ازای $M$ های 50،100،500، 1000 بیان میکند.
4 عکس اول برای 
$\frac{A}{M}=1.2$
 است(نسبت ثابت $A$ به $M$). با تغییر در تابع sinenoise میتوان $A$ را تغییر داد.  به طور پیش فرض $1.2 M$ است. (برای نشان دادن عملکرد خوب طیف گسترده در نویز های منطقی)
\begin{figure}[H]
\centerline{\includegraphics[scale=0.8]{project_imgs/resultM=50.png}}
\caption*{$M=50$}
\end{figure}
\begin{figure}[H]
\centerline{\includegraphics[scale=0.8]{project_imgs/resultM=100.png}}
\caption*{$M=100$}
\end{figure}
\begin{figure}[H]
\centerline{\includegraphics[scale=0.8]{project_imgs/resultM=500.png}}
\caption*{$M=500$}
\end{figure}
\begin{figure}[H]
\centerline{\includegraphics[scale=0.8]{project_imgs/resultM=1000.png}}
\caption*{$M=1000$}
\end{figure}

4 عکس بعدی برای $A=1100$ است و دامنه در آن به ازای 4 $M$ مختلف ثابت است. پیش فرض برای $A$ در تابع $1.2M$ است. برای دیدن نتایج زیر کافی است مقدار $A$ را در تابع sinnoise
مساوی 1100 بگذارید.
\begin{figure}[H]
\centerline{\includegraphics[scale=0.8]{project_imgs/M=50_1.png}}
\caption*{$M=50$}
\end{figure}
\begin{figure}[H]
\centerline{\includegraphics[scale=0.8]{project_imgs/M=100_1.png}}
\caption*{$M=100$}
\end{figure}
\begin{figure}[H]
\centerline{\includegraphics[scale=0.8]{project_imgs/M=500_1.png}}
\caption*{$M=500$}
\end{figure}
\begin{figure}[H]
\centerline{\includegraphics[scale=0.8]{project_imgs/M=1000_1.png}}
\caption*{$M=1000$}
\end{figure}

همانطور که مشاهده میکنیم، در $A$ ثابت با افزایش $M$ خطای ما بسیار کاهش میابد.
\section{مزایا و پاسخ به سوالات}
همان طور که در توضیحات نیز ذکر شد، مزیت طیف گشترده یکی در پخش کردن سیگنال تداخلی در حوزه فرکانس است که باعث میشود بخشی از طیف های آن از فیلتر عبور کند. دیگر مزیت آن در detector و هنگام جمع زدن است که اثر بیت تداخلی را در مقابل بیت داده کمتر مبکند. این را در بند اول detector توضیح داده ایم. jammer سعی میکتد بیت تداخلی با دامنه ای بزرگتر از اندازه داده ها ارسال کند اما در بخش جمع کننده‌ی detector با جمع کردن نمونه ها، توان و اثر داده ها زیاد خواهد شد و به مرتبه $M$ خواهد رسید. همان طور که مشاهده شد،با بیشتر شدن $M$ نتیجه بهتری خواهیم گرفت چون نمونه ها بیشتر هستند.

مزیت دیگر آن در دسترسی چندگانه از کانال است که تنها فرستنده و گیرنده مورد نظر از $PN$ اطلاع دارند. و ضرب دو $PN$ متفاوت در هم یک سینگال نویز مانند تولید میکند پس بیت های فرستنده های دیگر مانند نویز میشوند و تنها سیگنال مورد نظر (بعد از دمودوله و ...) به عنوان داده به گیرنده میرسد.

با افزایش $N$ این مزیت ها بیشتر میشود.

\textbf{میتوانید با کپی کردن کدها از فایل fourier.txt و پیست کردن آن در پایان هر یک از Mfile ها تبدیل فوریه مراحل را به ترتیب مشاهده فرمایید. }
\end{persian}
\end{document}